/* STM32F103C8T6 + 74HC595 x2 + 74HC165(H,G,F)
   165:  PA4=QH, PA5=CLK, PA6=SH/LD#
   595:  PA0 -> SER, PA1 -> OE#(低有效), PA2 -> RCLK, PA3 -> SRCLK
   U34.QH' -> U33.SER
   PB0 -> PWM
   这里把 PB10 / PB11 当成来自电机的霍尔/脉冲输入
*/

#define PIN_SER    PA0
#define PIN_OE     PA1
#define PIN_RCLK   PA2
#define PIN_SRCLK  PA3
#define PIN_PWM    PB0
#define PIN_PB10   PB10
#define PIN_PB11   PB11

// ---- 74HC165 ----
#define PIN_165_QH     PA4
#define PIN_165_CLK    PA5
#define PIN_165_SHLD   PA6

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define OLED_WIDTH   128
#define OLED_HEIGHT   64
#define OLED_RESET    -1
const uint8_t OLED_ADDR = 0x3C;

Adafruit_SSD1306 display(OLED_WIDTH, OLED_HEIGHT, &Wire, OLED_RESET);

// ===== 595 脉冲 =====
inline void pulseSRCLK() { digitalWrite(PIN_SRCLK, HIGH); digitalWrite(PIN_SRCLK, LOW); }
inline void pulseRCLK()  { digitalWrite(PIN_RCLK,  HIGH); digitalWrite(PIN_RCLK,  LOW); }

// ===== 发送 16 位到 74HC595（高字节先发）=====
void shiftOut16(uint8_t highByte, uint8_t lowByte) {
  digitalWrite(PIN_OE, LOW); // 使能输出
  for (int8_t i = 7; i >= 0; --i) { digitalWrite(PIN_SER, (highByte >> i) & 0x01); pulseSRCLK(); }
  for (int8_t i = 7; i >= 0; --i) { digitalWrite(PIN_SER, (lowByte  >> i) & 0x01); pulseSRCLK(); }
  pulseRCLK();
}
inline void motorForward() { shiftOut16(0x00, 0x01); } // 示例
inline void motorReverse() { shiftOut16(0x01, 0x00); }
inline void motorStop()    { shiftOut16(0x00, 0x00);  }

const uint8_t SPEED_PERCENT = 90;
inline uint8_t pctToDuty(uint8_t p){ return (uint8_t)((p * 255UL) / 100UL); }

// ===== 读取 74HC165 的 H、G、F 三位 =====
uint8_t read165_HGF() {
  digitalWrite(PIN_165_SHLD, LOW);            // 并行装载
  delayMicroseconds(1);
  digitalWrite(PIN_165_SHLD, HIGH);           // 进入移位
  uint8_t H = digitalRead(PIN_165_QH);        // 此时为 H
  digitalWrite(PIN_165_CLK, HIGH); digitalWrite(PIN_165_CLK, LOW);
  uint8_t G = digitalRead(PIN_165_QH);        // 移到 G
  digitalWrite(PIN_165_CLK, HIGH); digitalWrite(PIN_165_CLK, LOW);
  uint8_t F = digitalRead(PIN_165_QH);        // 移到 F
  return (uint8_t)((H<<2)|(G<<1)|(F<<0));     // bit2=H, bit1=G, bit0=F
}

// ====== 霍尔/脉冲统计（PB10 / PB11）- 保留但不使用 ======
volatile uint32_t pb10_count = 0;
volatile uint32_t pb11_count = 0;
void ISR_pb10() { pb10_count++; }
void ISR_pb11() { pb11_count++; }

// ====== 165 信号变化检测（H/G/F = 限位开关）======
uint8_t last_hgf = 0xFF;  // 上次的 HGF 值
uint32_t hgf_change_count = 0;  // HGF 变化次数
uint32_t hgf_history[10];  // 记录最近10次变化的时间戳
uint8_t hgf_values[10];    // 记录最近10次的 HGF 值
uint8_t history_index = 0;

// 频率统计用
uint32_t last_ms = 0;
uint32_t last_pb10_cnt = 0, last_pb11_cnt = 0;
float    freq_pb10 = 0.0f, freq_pb11 = 0.0f;

void setup() {
  // 595
  pinMode(PIN_SER,   OUTPUT);
  pinMode(PIN_OE,    OUTPUT);
  pinMode(PIN_RCLK,  OUTPUT);
  pinMode(PIN_SRCLK, OUTPUT);
  pinMode(PIN_PWM,   OUTPUT);

  // 165
  pinMode(PIN_165_QH,   INPUT);
  pinMode(PIN_165_CLK,  OUTPUT);
  pinMode(PIN_165_SHLD, OUTPUT);
  digitalWrite(PIN_165_CLK,  LOW);
  digitalWrite(PIN_165_SHLD, HIGH);

  // 霍尔/脉冲输入（启用上拉，兼容开漏输出）
  pinMode(PIN_PB10, INPUT_PULLUP);
  pinMode(PIN_PB11, INPUT_PULLUP);

  // 595 初始化
  digitalWrite(PIN_SER,   LOW);
  digitalWrite(PIN_RCLK,  LOW);
  digitalWrite(PIN_SRCLK, LOW);
  digitalWrite(PIN_OE, HIGH);
  shiftOut16(0x00, 0x00);
  digitalWrite(PIN_OE, LOW);

  analogWrite(PIN_PWM, 0);

  // OLED
  Wire.begin();
  display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,0);
  display.println("165 & Hall Monitor");
  display.display();

  // 中断计数：检测所有跳变（CHANGE），兼容推挽和开漏
  attachInterrupt(digitalPinToInterrupt(PIN_PB10), ISR_pb10, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_PB11), ISR_pb11, CHANGE);

  last_ms = millis();
}

void drawOLED(uint8_t hgf, uint32_t change_cnt) {
  display.clearDisplay();
  display.setTextSize(1);

  // 第一行：165 当前状态（二进制和十进制）
  display.setCursor(0, 0);
  display.print("HGF: ");
  for (int i=2;i>=0;--i) display.print( ((hgf>>i)&1)?'1':'0' );
  display.print(" (");
  display.print(hgf);
  display.print(")");

  // 第二行：状态解释
  display.setCursor(0, 12);
  if (hgf == 0b001) {
    display.print("State: EXTENDED"); // 全伸出
  } else if (hgf == 0b100) {
    display.print("State: RETRACTED"); // 全收缩
  } else if (hgf == 0b101) {
    display.print("State: MOVING"); // 运动中
  } else {
    display.print("State: UNKNOWN");
  }

  // 第三行：变化计数
  display.setCursor(0, 24);
  display.print("Changes: ");
  display.print(change_cnt);

  // 第四行和第五行：最近3次变化历史
  display.setCursor(0, 36);
  display.print("History (recent):");
  display.setCursor(0, 48);
  for (int i = 0; i < 3; i++) {
    int idx = (history_index - 1 - i + 10) % 10;
    if (hgf_history[idx] > 0) {
      uint8_t val = hgf_values[idx];
      display.print(val);
      display.print(" ");
    }
  }

  // 第六行：H、G、F 单独显示
  display.setCursor(0, 56);
  display.print("H:");
  display.print((hgf>>2)&1);
  display.print(" G:");
  display.print((hgf>>1)&1);
  display.print(" F:");
  display.print(hgf&1);

  display.display();
}

void loop() {
  // 你原来的电机驱动（示例）
  motorForward();
  // motorReverse();
  analogWrite(PIN_PWM, pctToDuty(SPEED_PERCENT));

  // ==== 高频读取 165（检测限位开关变化）====
  uint8_t hgf = read165_HGF();

  // 检测 HGF 变化
  if (hgf != last_hgf && last_hgf != 0xFF) {
    hgf_change_count++;
    // 记录到历史
    hgf_history[history_index] = millis();
    hgf_values[history_index] = hgf;
    history_index = (history_index + 1) % 10;
  }
  last_hgf = hgf;

  // OLED 显示：当前状态和变化历史
  drawOLED(hgf, hgf_change_count);

  // 缩短刷新周期到 5ms，提高采样率
  delay(5);
}
