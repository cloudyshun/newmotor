=================================================================
newmotor.ino G口正交解码问题修复说明
=================================================================

【问题现象】
G口的计数和频率始终不变，H口能正常变化
G、H口都是检测霍尔脉冲信号的正交编码输入

【根本原因】
74HC165芯片读取时序错误：
- 在CLK时钟脉冲后立即读取QH引脚
- 没有给芯片足够的传播延迟时间（需要几十到100纳秒）
- 导致读取到的是旧数据或不稳定的数据

【具体分析】
read165_HGF()函数按顺序读取H、G、F三位：
1. H位 - 正常：SHLD切换后数据已在QH上，可直接读取 ✓
2. G位 - 异常：CLK脉冲后立即读，可能还是H的值 ✗
3. F位 - 异常：CLK脉冲后立即读，可能还是G的旧值 ✗

【修复方法】
在每次CLK脉冲后、读取QH之前，添加delayMicroseconds(1)延迟

修复前：
  digitalWrite(PIN_165_CLK, HIGH); digitalWrite(PIN_165_CLK, LOW);
  uint8_t G = digitalRead(PIN_165_QH);  // ✗ 立即读取

修复后：
  digitalWrite(PIN_165_CLK, HIGH); digitalWrite(PIN_165_CLK, LOW);
  delayMicroseconds(1);                  // ✓ 等待数据稳定
  uint8_t G = digitalRead(PIN_165_QH);  // ✓ 现在可以读到正确值

【修复的文件】
1. newmotor.ino - 第65-78行的read165_HGF()函数
2. store8.txt   - 第52-65行的read165_HGF()函数

【测试建议】
1. 烧录修复后的代码
2. 打开串口监视器（9600波特率）
3. 观察每秒输出的调试信息：
   HGF=0b... G=... H=... g_count=... h_count=...
4. 手动转动电机，确认g_count和h_count都在增加
5. 观察OLED显示：FreqG和FreqH都应该有数值

【正交解码逻辑说明】
当前使用单边沿解码：
- 只在G相(A相)变化时检测方向
- 通过比较current_g和current_h判断旋转方向
- if (current_g == current_h) 则position++，否则position--

如果实际测试发现方向反了，将判断条件改为：
  if (current_g != current_h) { position++; }

【技术细节】
- 74HC165传播延迟：典型25ns，最大100ns @ 5V
- 1微秒延迟既保证可靠性，又不影响轮询频率
- loop轮询频率从~300kHz降到~200kHz
- 对霍尔脉冲信号（通常<10kHz）完全足够

=================================================================
